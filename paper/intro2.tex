According to the Cryptographers' Feedback on the EU Digital Identity’s ARF\footnote{\url{https://github.com/user-attachments/files/15904122/cryptographers-feedback.pdf}}, an Anonymous Credential AC scheme, is a suitable cryptographic primitive to instantiate the new EU Digital Identity Wallet (EUDIW) which is an important step towards developing interoperable digital identities in Europe for the public and private sectors.

Informally speaking, an Anonymous Credential AC scheme allows:
\begin{itemize}
	\item An Identity Provider IP to (possibly blindly\footnote{i.e. the IP does not know the content that it signs, only its provenance is satisfied.}) sign a set of (eligible) attributes for a User U;
	\item The User U can show, only if they hold the signed attributes (a.k.a Unforgebality), usually through a Presentation, to a Relying Party RP such that:
	\begin{itemize}
		\item The RP can verify that the set of attributes (signed by IP) that the User U holds satisfy some condition of their interest (a.k.a Correctness);
		\item The RP cannot learn any \emph{additional}\footnote{We stress that the RP may have obtained some privacy sensitive information prior to this presentation.} information beyond the fact that the condition is satisfied or information that can be inferred from the satisfaction of the condition (a.k.a Zero-Knowledge or Anonymity);
		\item The immediate previous requirement also implies that the RP cannot link the various presentations by the same User U (a.k.a. Unlinkability);
	\end{itemize}
	\item The IP can revoke all or a part of the signed attributes that it has issued to the User U, from upon which, the eligible attributes of the User U are updated, and subsequent presentations have to be based on the new and updated attributes (a.k.a Revocation);
	\item The User U cannot transfer its set of signed attributes to to another User U' (a.k.a Non-transferability).
\end{itemize}

In the aforementioned feedback document, BBS and BBS+\footnote{For BBS, thanks to prior work by the W3C, the Decentralized Identity Foundation, IETF/IRTF, ISO, and other standardization bodies, as well as the availability of open-source software libraries, the EC can develop a standard and reference implementation with only a modest effort. The feedback additionally recommend that the EUDI be designed following the principle of crypto-agility, meaning that its underlying technologies can be upgraded quickly in the future if the need arises.} were promoted as the main candidate, besides that, there have been two independent work from Google and Microsoft that attempted to offer candidate solutions. In this document, we attempt to offer a new candidate, called \textbf{zkID}.

In comparison, these approaches show the current trade-off: systems either reuse existing issuer infrastructure but pay high per-presentation costs, or they achieve fast online proofs at the price of large setups and pairing-based assumptions. Our construction, zkID, aims to combine issuer compatibility with reusable offline work, while remaining transparent and modular.

\subsection{Our zkID}
Let us first outline a reference architecture that represents what an anonymous-credential system would ideally look like if it is to integrate smoothly with current infrastructures. In this model, the issuer is treated as fixed components that continue to use their existing public-key algorithms (such as RSA or ECDSA) and standard credential formats (e.g., JWT or mDL), since it's typically difficult to change once deployed. All additional logic is placed in the user’s wallet and the verifier.
The wallet is expected to operate in two stages: an offline Prepare step, which verifies the issuer’s signature once using standard libraries, parses and normalizes credential attributes (for example, turning a date of birth into an integer age), and commits to those attributes using a binding and hiding commitment scheme (a cryptographic way to lock values so they can later be revealed or proven in restricted form); and an online Show step, which runs per presentation, where the wallet selects only the attributes or predicates required by a relying party’s policy, proves them in zero knowledge against the stored commitments, and includes a fresh device signature over the session challenge to ensure the proof is tied to the holder’s device.
A further requirement is modularity: each major function---issuer signature verification, attribute commitment, predicate proofs, and device binding---should be defined as a separate module with a clear interface. This separation makes it possible to swap the underlying proof engine (for example, using a SNARK today or a post-quantum proof system in the future) without requiring changes to parts of the system that are costly or impractical to modify. The purpose of this modular view is to act as a comparison framework: it outlines how a deployment-friendly anonymous-credential stack could be structured, making it easier to compare proposals by the modules they cover, the constraints they address, and the trade-offs they make.

Our construction works with standardized credentials (e.g., SD-JWT, mDL) and existing PKI (RSA/ECDSA), so issuers do not need to change their issuance pipelines.
The zkID workflow follows the two-phase split in the reference view: a one-time Prepare phase and a per-presentation Show phase.
In Prepare, the wallet verifies the issuer’s signature, parses the credential into normalized messages, computes the associated hashes, and produces two reusable artifacts: (i) zero-knowledge proofs that issuer-side checks and parsing were done correctly, and (ii) Hyrax-style Pedersen vector commitments to a designated message column, supporting efficient proofs over multiple attributes.
In Show, the wallet proves only the verifier’s requested predicates and includes a fresh device-binding signature. To link Prepare and Show without revealing values, the verifier checks equality of commitments across both proofs; the wallet reuses the corresponding randomness for that session.
The proving backend is transparent (no trusted setup). It checks the arithmetic constraints with a sum-check–style protocol and uses a small inner-product check to verify commitment openings. For device binding, we choose a curve whose scalar field matches the device’s signature field (e.g., P-256), so the device signature can be verified directly inside the proof without emulation or field translation. 
In terms of the reference system view, issuer compatibility is preserved, the two-phase reuse is integrated into the workflow, predicates are modular, and there is no trusted setup. The trade-offs are that security currently relies on discrete-log assumptions (not post-quantum) and that commitment equality requires using the same curve across Prepare and Show; the modular interface leaves room to swap in lattice-based commitments when suitable.
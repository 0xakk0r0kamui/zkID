At a high-level, we propose a generic zkSNARK wrapper over a credential, which will either in SD-JWT format or the mDL data format specified in standard \href{https://mobiledl-e5018.web.app/ISO_18013-5_E_draft.pdf}{ISO/IEC 18013-5}). The backend proving system we use will be a combination of Spartan and Hyrax commitments, with modifications to be zero-knowledge. 

There are two (2) key ideas to highlight within our proposed architecture:

\begin{itemize}
    \item \textbf{Pre-processing batches of re-randomized proofs} of issuer-signature and credential-parsing, to re-use across each new presentation. We call this the `prepare` relation.
    \item \textbf{Committing to the credential disclosures with Hyrax commitments} \cite{cryptoeprint:2017/1132} to get linking across circuits ``for free''
\end{itemize}

For the first item, we note that pre-processing proofs for the ``prepare'' relation is possible because the relation is independent of the presentation, including the choice of disclosures or predicate proofs. Further optimizations can likely be made to only parse the discosures of certain attributes within the credential if it is known that the Wallet User will rarely or never present certain disclosures to external verifiers.
The second idea differs from the linking circuits approach that Google uses \cite{cryptoeprint:2024/2010}. Note that Google verifiably computes a hiding and binding MAC of the shared witnesses as a public output of the circuit, which the verifier checks consistency of in plain. Although this is only a few linear relations, it requires the prover to also commit to their portion of the key to prevent forging. We instead simply manually separate out the disclosures $m_1, \dots, m_n$ into a designated column when committing to the witness, which is already needed to prove the circuit relation, and the verifier checks consistency of these commitments when verifying each circuit's proof.

Throughout the remainder of this section, we refer to the EUDI's Wallet User as the ``Prover'', the Relying Party as the ``Verifier'', and the ``EUDI Attestation Authority (EAA)''. Below, we briefly detail a high-level flow of the interaction between the Issuer, Prover, and Verifier.

\subsubsection{High-Level Credential Issuance and Presentation Flow}\label{sec:high-level-flow}

\begin{enumerate}
\item The Prover receives a signed credential from an Issuer to be stored securely in their wallet, issued to the Wallet Secure Cryptographic Device (WSCD) public key.
\item At presentation time, the Verifier sends over challenge $\texttt{nonce}_V$ for device-binding
\item The Prover signs the challenge \texttt{nonce} with the public key $p_U$ controlled by their WSCD and specified in their credential
\item The Prover computes a zero-knowledge proof $\pi$ of SD-JWT parsing, verification of the SD-JWT Issuer signature, 
proper disclosures and/or arbitrary predicates on the disclosures, and device-binding 
(i.e.\ checks the \texttt{nonce} signature against their public key); The Prover sends $\pi$ to the Verifier.
\item The Verifier receives and verifies the $\pi$, and grants Prover access to some service based on their credential disclosures.
\end{enumerate}

\subsection{Underlying ZK Circuit}

In this section, we describe our high-level ZK circuit $C$ underlying the knowledge the prover actually needs to present to the verifier.
Throughout, we refer to the Issuer with variable $I$, Prover with variable $P$, and Verifier with variable $V$ (e.g. in subscripts). 

We will detail the ZK wrapper around the SD-JWT credential as an example, but the protocol is analogous for other credential formats. 
Throughout, we will refer to digests as ``message hashes'' or just ``hashes'', and disclosures as ``messages''.

We define a circuit $C$ for proving ownership of an anonymous credential. 
We let our witness $w = S$ be the SD-JWT credential consisting of messages $\{m_i\}_{i=1}^N$, hash salts $\{s_i\}_{i=1}^N$, 
hashes $\{h_i\}_{i=1}^N$, and an Issuer signature $\sigma_I = \sigma(h_1, \dots, h_N; SK_I)$. 
Without loss of generality, we assume that the Prover's public key $PK_P$ is contained in message $m_1$ of the credential and indexable as $m_1[1]$.
We let our instance $x = (PK_I, \{f_i\}_{i=1}^K, \{p_i\}_{i=1}^K)$ contain the Issuer's public key $PK_I$, functions $f_i$ over the messages, 
output predicates $p_i$, and finally the nonce signature $\sigma_{\text{nonce}}$ for proving device-binding. 
The $f_i$ can be arbitrary statements we wish to prove about the messages. For example, one could define a function $f_i(m_1, \dots, m_N) = m_1$ would output a predicate that is just the disclosure of message $m_1$.

\begin{mdframed}[style=zkprotocolwithheader, frametitle=Underlying ZK Circuit $C$ for Verifiable Credential]

We define circuit $C(x = (PK_I, \{f_i\}_{i=1}^K, \{p_i\}_{i=1}^K), w_C = (S))$ as follows:

\begin{enumerate}
\item Assert $\text{parse}_{\text{SD-JWT}}(S) = (\{m_i\}, \{s_i\}, \{h_i\}_i, \sigma_I)$ parsing of the SD-JWT into messages $\{m_i\}_{i=1}^N$, message salts $\{s_i\}_{i=1}^N$, hashes $\{h_i\}_{i=1}^N$ and Issuer signature $\sigma_I$.
\item Assert $h_i = \text{SHA256}(m_i, s_i) \quad \forall i \in [n]$, i.e.\ that messages hashes correspond to messages and salts
\item Assert $p_i = f_i(m_1, \dots, m_n) \quad \forall i \in [n]$ , i.e.\ correct evaluation of the predicates
\item Assert $\text{ECDSA.verify}(\sigma_I, PK_I) = 1$, i.e.\ the credential signature verifies under the Issuer public key
\item Assert $\text{ECDSA.verify}(\sigma_{\text{nonce}}, m_1[1]) = 1$, i.e.\ that the live nonce signature corresponds to the public key the credential was issued to
\end{enumerate}

\end{mdframed}

\subsection{Pre-processing and linking proofs}

The main speedups from our proving system will come from splitting our high-level circuit $C$ above into two (2) circuits for different relations regarding the digital credential, 
namely a \texttt{prepare} and a \texttt{show} relation, analogous to Microsoft's Crescent Credentials \cite{cryptoeprint:2024/2013}. 
This is advantageous because proofs of the \texttt{prepare} relation can be computed a-priori for any credential, as they do not depend on the claim being proved at presentation time. 
Pre-computing these proofs will save significant time per presentation, and reduce the performance bottleneck to that of proving the \texttt{show} relation.

One issue that arises is the need to ensure consistency of witnesses across these separate circuits, or what we call ``linking proofs''. 
At a high level, as opposed to Google's MAC approach \cite{cryptoeprint:2024/2010}, the prover sends Hyrax commitments to the parts of the witness re-used across circuits, 
which ends up being just the raw messages $\{m_i\}_i$. 
The verifier can then check consistency of these witnesses across the circuits $C_i$ by comparing the commitments they receive as part of the proof. 
This approach gives us linking ``for free'', as the Prover alreadys compute these Hyrax commitments as part of the proof.

We also want to highlight that we are no longer splitting up circuits by their field operations 
(e.g. SHA256 attestations over a binary extension field and an ECDSA verifications over a prime field), but rather we only split up our circuit by pre-processing and per-presentation relations. 
In particular, the circuit for \texttt{prepare} will necessarily involve wrong-field arithmetic by including both the SHA256 hashes and the Issuer ECDSA signature verification. 
However, because of our ability to pre-compute proofs of the ``prepare'' relation, the more important thing is to choose curves that allow for i) efficient show relations and ii) linking the prepare and show relation. 
Since the verifier can only check equality of Hyrax Pedersen commitments defined over the same curve, we must use the same curve for proving both the \texttt{prepare} and \texttt{show} relations.
Thus we choose a curve with a scalar field equivalent to the base field of the nonce signature $\sigma_{\text{nonce}}$ for efficient signature verification. 
Because most Hardware Security Modules (HSMs) sign over the P256 curve, we choose the Tom256 (T256) curve for our backend, which has scalar field equivalent to the base field of P256. 

We now detail each of the two (2) relations/circuits below.

\subsubsection{The \texttt{prepare} relation:}

The \texttt{prepare} relation checks the validity of issuer signature, parses the SD-JWT, and verifies all the message hashes, none of which depend on the specific presentation. 
Thus, the prover will periodically pre-compute and store a batch of re-randomized proofs of the prepare relation. 
These proofs will utilize Hyrax Pedersen vector commitments as introduced above in order to link the proofs of \texttt{prepare} relation to the \texttt{show}. 

\begin{mdframed}[style=zkprotocolwithheader, frametitle=Circuit $C_1$ for the \texttt{prepare} relation]

We define circuit $C(x = (PK_I), w_i = S, w = (\{m_i\}_{i=1}^N))$ as follows:

\begin{enumerate}
\item Assert $\text{parse}_{\text{SD-JWT}}(S) = (\{m_i\}, \{s_i\}, \{h_i\}_i, \sigma_I)$ parsing of the SD-JWT into messages $\{m_i\}_{i=1}^N$, message salts $\{s_i\}_{i=1}^N$, hashes $\{h_i\}_{i=1}^N$ and Issuer signature $\sigma_I$.
\item Assert $h_i = \text{SHA256}(m_i, s_i) \quad \forall i \in [n]$, i.e.\ that messages hashes correspond to messages and salts
\item Assert $\text{ECDSA.verify}(\sigma_I, PK_I) = 1$, i.e.\ the credential signature verifies under the Issuer public key
\end{enumerate}

\end{mdframed}

To produce zkSNARK proofs for this circuit $C_1$, the prover will proceed in two phases:
\begin{enumerate}
\item \texttt{prepareCommit}: Computes a Hyrax commitment $com = com(m_1, \dots, m_N; r_1)$ for all $i \in [m]$ to the witness column containing message hashes $m_i$ using initial randomness $r_1$. 
\item \texttt{prepareBatch}: 
    \begin{enumerate}
        \item Re-randomizes these commitments $com_i = com(m_1, \dots, m_N; r_i) = com \cdot g_{N+1}^{r_i-r_1}$ for all $i \in [m]$, 
        where our batch size $m$ depends on the frequency of proof generation and demand for the credential
        \item Continues the Spartan sumcheck IOP on each $com_i$ to produce a batch of proofs $\{\pi_i\}$ for $i \in [m]$ of the ``prepare'' relation.
    \end{enumerate}
\end{enumerate}
    
The prover will run \texttt{prepareBatch} periodically to both generate re-randomized commitments $com_i$ and store their randomness $r_i$ (for linking purposes), as well as generate and store batches of issuer-signature proofs $\pi_i$ that can be used for each presentation.

\subsubsection{The \texttt{show} relation:}

At a high-level, our show relation will i) verifiably compute any functions $f_i$ over the SD-JWT messages (such as disclosures, range checks, etc.),
and ii) check that the credential belongs to the prover's device (also known as proof of ``device-binding''). 
As part of device-binding, the prover will sign a verifier \texttt{nonce} outside of the circuit, as outlined in flow \ref{sec:high-level-flow}. 
Let us denote this signature by $\sigma_P = \sigma(\text{nonce}; SK_P)$

Again, we will use T256 curve for our backend proving system so that the holder in-circuit signature verification can proceed naturally in the right field.

\begin{mdframed}[style=zkprotocolwithheader, frametitle=Circuit $C_2$ for the \texttt{show} relation]

We define circuit $C(x = (\{f_i\}_{i=1}^K, \{p_i\}_{i=1}^K), w = \{m_i\}_{i=1}^N)$ as follows:

\begin{enumerate}
\item Assert $p_i = f_i(m_1, \dots, m_n) \quad \forall i \in [n]$, i.e. correct evaluation of the predicates
\item Assert $\text{ECDSA.verify}(\sigma_{\text{nonce}}, m_1[1]) = 1$, i.e. that the live nonce signature corresponds to the public key the credential was issued to
\end{enumerate}

\end{mdframed}

As part of the proof for presentation $i \in [m]$, the prover computes the Hyrax commitment over the Tom256 curve $com(m_1, \dots, m_N; r_i)$, 
notably with the same randomness $r_i$ as during the \texttt{prepareBatch} process, in the proof generation. 
The verifier will check that this equals the re-randomized commitment $com_i$ from proof $\pi_i$ for circuit $C_1$. 

\section{Cost analysis}

Spartan ZK sumcheck with hyrax communication cost (proof length):
- prover sends over polynomials for each of n = log|W| dimensions, which can be represented by 2 field elements each ---> 2n = 2 log|W| F elts
- challenges r_i are public
- one pedersen + IPA for linear relations on the padded transcript. have f_n(r_n) be a public output tho in the last column... --> 2 log n = 2 log (log|W|) G elts
- one pedersen + IPA for the opening of the polynomial (aka proving the last row of public output vector is PCS opening) --> 2 log |W| G elts

verification time:
- linear relations on sumcheck: O(log|W|) group operations
- MLE opening: O(|W|) group operations 

so opening the ML in ZK is the main bottleneck for proving. sumcheck is not that bad because the input size of stuff is already log|W|

% \begin{enumerate}
%     \item What are key techniques that will be used in our schemes?
%     \begin{itemize}
%         \item What are its inputs and outputs?
%         \item Participants and requirements of the techniques.
%     \end{itemize}
%     \item Describes the complete scheme, from preparation to verification. 
%     \begin{itemize}
%         \item The preliminaries of users when they use our system.
%         \item What is the difference between the preparation of this scheme and the traditional way?
%         \item Some questions we also answer here but just with a compact version, the detailed or proof will be shown in Security or Appendix section.
%         \begin{itemize}
%             \item Is it a dishonest majority setting or something else? 
%             \item What happens when the setting is broken?
%             \item What trust assumptions are our scheme based on?
%             \item Is this quantum-resistant? If not, is it upgradable to quantum-resistant?
%             \item The correctness, soundness, and zk.
%         \end{itemize}
%     \end{itemize}
%     \item Discuss about the compatibility of our system when upgrading from an older system.
%     \begin{enumerate}
%         \item What happens with the older system?
%         \begin{itemize}
%             \item Is it required to change the issuance process? 
%             \item Is it a breaking change or just a soft update?
%             \item What happens with the issued ID, can it be re-used, and re-issued with a new scheme?
%             % should be revoked
%             \item \textbf{It depends on the answer about the final construction. But we have some design constraints that should be followed, which are described in slide 111 of \href{https://docs.google.com/presentation/d/1C4D8zK4gAdafgIEW-2m_qDyyT39gWo0mmFYpwmA8N3M/edit?slide=id.g338a079cb64_0_31\#slide=id.g338a079cb64_0_31}{this doc}} 
%         \end{itemize} 
%         \item What about the new PID?
%         \begin{enumerate}
%             \item What is the difference between the PID of the new scheme and the current version? Is it added more data fields to the current struct?
%             \item If not, is the process from PID to scheme input straightforward (and provable?)?
% % \textbf{            \item What if the Issuer or the ID owner wants to revoke some IDs, does it require the Issuer to update frequently? -- still need to add this}            \item If the Issuer needs to update frequently, what if they are disconnected for a while? 
%             \item What is the trust assumption?
%         \end{enumerate}
%     \end{enumerate}
%     \item After show the detailed construction, we will show more detailed about why our construction should be considered with some detailed.
%     \begin{enumerate}
%         \item What are the main advantages that make zkID outperform other solutions? 
%             \item TODO: wait for benchmarks from the technical team 
%         \item What are the trade-offs if users take our advancement?
%     \end{enumerate}
% \end{enumerate}

At a high-level, we propose a generic zkSNARK wrapper over a credential, which will either in SD-JWT format or the mDL data format specified in standard \href{https://mobiledl-e5018.web.app/ISO_18013-5_E_draft.pdf}{ISO/IEC 18013-5}). The backend proving system we use will be a combination of Spartan and Hyrax commitments, with modifications to be zero-knowledge. 

There are two (2) key ideas to highlight within our proposed architecture:

\begin{itemize}
    \item \textbf{Pre-processing batches of re-randomized proofs} of issuer-signature and credential-parsing, to re-use across each new presentation. We call this the \texttt{prepare} relation.
    \item \textbf{Committing to the credential disclosures with Hyrax commitments} \cite{cryptoeprint:2017/1132}, which allows us to re-use (or ``link'') witnesses across circuits ``for free''
\end{itemize}

For the first item, we note that pre-processing proofs for the \texttt{prepare} relation is possible because the relation is independent of the presentation, including the choice of disclosures or predicate proofs. 
Further optimizations can likely be made to only parse the discosures of certain attributes within the credential if it is known that the Wallet User will rarely or never present certain disclosures to external verifiers.

The second items differs from the linking circuits approach that Google uses \cite{cryptoeprint:2024/2010}. 
Note that Google verifiably computes a hiding and binding MAC of the shared witnesses as a public output of the circuit, which the verifier checks consistency of in plain. 
Although this is only a few linear relations, it requires the prover to also commit to their portion of the key to prevent forging. 
We instead simply manually separate out the disclosures $m_1, \dots, m_n$ into a designated column when committing to the witness, which is already needed to prove the circuit relation. 
Then, the verifier simply checks consistency of these commitments when verifying each circuit's proof.

We note that by using Hyrax commitments, our PoC is not post-quantum secure. 
In particular, post-quantum computers break the discrete-log assumption, which breaks the binding property of the polynomial commitment scheme.
Thus, a malicious Prover could potentially make false proofs about their identity. 
In future work, we hope to incorporate modified Ajtai lattice-based commitments to ensure post-quantum security \cite{cryptoeprint:2024/306}.

Throughout the remainder of this section, we refer to the EUDI's Wallet User as the ``Prover'', the Relying Party as the ``Verifier'', and the EUDI Attestation Authority (EAA) as the ``Issuer''. Below, we briefly detail a high-level flow of the interaction between the Issuer, Prover, and Verifier.

% MOVED BELOW TO THE PRELIMS SECTION
% \subsection{High-Level Credential Issuance and Presentation Flow}\label{sec:high-level-flow}

% \begin{enumerate}
% \item The Prover receives a signed credential from an Issuer to be stored securely in their wallet, issued to the Wallet Secure Cryptographic Device (WSCD) public key.
% \item At presentation time, the Verifier sends over challenge $\texttt{nonce}_V$ for device-binding verification
% \item The Prover signs the challenge \texttt{nonce} with the public key $p_U$ controlled by their WSCD and specified in their credential
% \item The Prover computes two separate but linked zero-knowledge proofs $\pi_{\text{\texttt{prepare}}}, \pi_{\text{\texttt{show}}}$ which together cover the following statements: SD-JWT parsing, verification of the SD-JWT Issuer signature, 
% proper disclosures and/or arbitrary predicates on the disclosures, and device-binding 
% (i.e.\ checks the \texttt{nonce} signature against their public key); then sends $\pi_{\text{\texttt{prepare}}}, \pi_{\text{\texttt{show}}}$ to the Verifier.
% \item The Verifier verifies $\pi_{\text{\texttt{prepare}}}, \pi_{\text{\texttt{show}}}$ independently, and also verify that they are linked; grants Prover access to some service based on their credential disclosures.
% \end{enumerate}

\subsection{Underlying ZK Circuit}

In this section, we describe our high-level ZK circuit $C$ underlying the knowledge the prover actually needs to present to the verifier.
Throughout, we refer to the Issuer with variable $I$, Prover with variable $P$, and Verifier with variable $V$ (e.g. in subscripts). 

We will detail the ZK wrapper around the SD-JWT credential as an example, but the protocol is analogous for other credential formats. 
Throughout, we will refer to digests as ``message hashes'' or just ``hashes'', and disclosures as ``messages''.

We define a circuit $C$ for proving ownership of an anonymous credential. 
We let our witness $w = S$ be the SD-JWT credential consisting of messages $\{m_i\}_{i=1}^N$, hash salts $\{s_i\}_{i=1}^N$, 
hashes $\{h_i\}_{i=1}^N$, and an Issuer signature $\sigma_I = \sigma(h_1, \dots, h_N; SK_I)$. 
Without loss of generality, we assume that the Prover's public key $PK_P$ is contained in message $m_1$ of the credential and indexable as $m_1[1]$.
We let our instance $x = (PK_I, \{f_i\}_{i=1}^K, \{p_i\}_{i=1}^K)$ contain the Issuer's public key $PK_I$, functions $f_i$ over the messages, 
output predicates $p_i$, and finally the nonce signature $\sigma_{\text{nonce}}$ for proving device-binding. 
The $f_i$ can be arbitrary statements we wish to prove about the messages. For example, one could define a function $f_i(m_1, \dots, m_N) = m_1$ would output a predicate that is just the disclosure of message $m_1$.

\begin{mdframed}[style=zkprotocolwithheader, frametitle=Underlying ZK Circuit $C$ for Verifiable Credential]

We define circuit $C(x = (PK_I, \{f_i\}_{i=1}^K, \{p_i\}_{i=1}^K), w_C = (S))$ as follows:

\begin{enumerate}
\item Assert $\text{parse}_{\text{SD-JWT}}(S) = (\{m_i\}, \{s_i\}, \{h_i\}_i, \sigma_I)$ parsing of the SD-JWT into messages $\{m_i\}_{i=1}^N$, message salts $\{s_i\}_{i=1}^N$, hashes $\{h_i\}_{i=1}^N$ and Issuer signature $\sigma_I$.
\item Assert $h_i = \text{SHA256}(m_i, s_i) \quad \forall i \in [n]$, i.e.\ that messages hashes correspond to messages and salts
\item Assert $p_i = f_i(m_1, \dots, m_n) \quad \forall i \in [n]$ , i.e.\ correct evaluation of the predicates
\item Assert $\text{ECDSA.verify}(\sigma_I, PK_I) = 1$, i.e.\ the credential signature verifies under the Issuer public key
\item Assert $\text{ECDSA.verify}(\sigma_{\text{nonce}}, m_1[1]) = 1$, i.e.\ that the live nonce signature corresponds to the public key the credential was issued to
\end{enumerate}

\end{mdframed}

\subsection{Pre-processing and linking proofs}

The main speedups from our proving system will come from splitting our high-level circuit $C$ above into two (2) circuits for different relations regarding the digital credential, 
namely a \texttt{prepare} and a \texttt{show} relation, analogous to Microsoft's Crescent Credentials \cite{cryptoeprint:2024/2013}. 
This is advantageous because proofs of the \texttt{prepare} relation can be computed a-priori for any credential, as they do not depend on the claim being proved at presentation time. 
Pre-computing these proofs will save significant time per presentation, and reduce the performance bottleneck to that of proving the \texttt{show} relation.

One issue that arises is the need to ensure consistency of witnesses across these separate circuits, or what we call ``linking proofs''. 
At a high level, as opposed to Google's MAC approach \cite{cryptoeprint:2024/2010}, the prover sends Hyrax commitments to the parts of the witness re-used across circuits, 
which ends up being just the raw messages $\{m_i\}_i$. 
The verifier can then check consistency of these witnesses across the circuits $C_i$ by comparing the Hyrax commitments they receive as part of the proof. 
This approach gives us linking ``for free'', as the Prover alreadys needs to compute these Hyrax commitments as part of the proof.

We also want to highlight that we are no longer splitting up circuits by their field operations 
(e.g. SHA256 attestations over a binary extension field and an ECDSA verifications over a prime field), but rather we only split up our circuit by pre-processing and per-presentation relations. 
In particular, the circuit for \texttt{prepare} will necessarily involve wrong-field arithmetic by including both the SHA256 hashes and the Issuer ECDSA signature verification. 
However, because of our ability to pre-compute proofs of the \texttt{prepare} relation, the more important thing is to choose curves that allow for i) efficient show relations and ii) linking the prepare and show relation. 
Since the verifier can only check equality of Hyrax Pedersen commitments defined over the same curve, we must use the same curve for proving both the \texttt{prepare} and \texttt{show} relations.
Thus we choose a curve with a scalar field equivalent to the base field of the nonce signature $\sigma_{\text{nonce}}$ for efficient signature verification. 
Because most Hardware Security Modules (HSMs) sign over the P256 curve, we choose the Tom256 (T256) curve for our backend, which has scalar field equivalent to the base field of P256. 

We now detail each of the two (2) relations/circuits below.

\subsubsection{The \texttt{prepare} relation:}

The \texttt{prepare} relation checks the validity of issuer signature, parses the SD-JWT, and verifies all the message hashes, none of which depend on the specific presentation. 
Thus, the prover will periodically pre-compute and store a batch of re-randomized proofs of the prepare relation. 
These proofs will utilize Hyrax Pedersen vector commitments as introduced above in order to link the proofs of \texttt{prepare} relation to the \texttt{show}. 

\begin{mdframed}[style=zkprotocolwithheader, frametitle=Circuit $C_1$ for the \texttt{prepare} relation]

We define circuit $C(x = (PK_I), w_i = S, w = (\{m_i\}_{i=1}^N))$ as follows:

\begin{enumerate}
\item Assert $\text{parse}_{\text{SD-JWT}}(S) = (\{m_i\}, \{s_i\}, \{h_i\}_i, \sigma_I)$ parsing of the SD-JWT into messages $\{m_i\}_{i=1}^N$, message salts $\{s_i\}_{i=1}^N$, hashes $\{h_i\}_{i=1}^N$ and Issuer signature $\sigma_I$.
\item Assert $h_i = \text{SHA256}(m_i, s_i) \quad \forall i \in [n]$, i.e.\ that messages hashes correspond to messages and salts
\item Assert $\text{ECDSA.verify}(\sigma_I, PK_I) = 1$, i.e.\ the credential signature verifies under the Issuer public key
\end{enumerate}

\end{mdframed}

To produce zkSNARK proofs for this circuit $C_1$, the prover will proceed in two phases:
\begin{enumerate}
\item \texttt{prepareCommit}: Computes a Hyrax commitment $com_1 = com(m_1, \dots, m_N; r_1)$ to the witness column containing message hashes $\{m_i\}_{i \in [N]}$ using initial randomness $r_1$. 
\item \texttt{prepareBatch}: 
    \begin{enumerate}
        \item Re-randomizes this initial commitment to get a batch of commitments $com_i = com(m_1, \dots, m_N; r_i) = com_1 \cdot g_{N+1}^{r_i-r_1}$ for all $i \in [m]$, 
        where our batch size $m$ depends on the frequency of proof generation and demand for the credential
        \item Continues the Spartan sumcheck IOP on each $com_i$ to produce a batch of proofs $\{\pi_{\texttt{prepare}}^{(i)}\}$ for $i \in [m]$ of the \texttt{prepare} relation.
    \end{enumerate}
\end{enumerate}
    
The prover will run \texttt{prepareBatch} periodically to both generate re-randomized commitments $com_i$ and store their randomness $r_i$ (for linking purposes), 
as well as generate and store batches of issuer-signature proofs $\pi_{\texttt{prepare}}^{(i)}$ that can be used for each presentation.

\subsubsection{The \texttt{show} relation:}

At a high-level, our show relation will i) verifiably compute any functions $f_i$ over the SD-JWT messages (such as disclosures, range checks, etc.),
and ii) check that the credential belongs to the prover's device (also known as proof of ``device-binding''). 
As part of device-binding, the prover will sign a verifier \texttt{nonce} outside of the circuit, as outlined in flow \ref{sec:high-level-flow}. 
Let us denote this signature by $\sigma_P = \sigma(\text{nonce}; SK_P)$

Again, we will use T256 curve for our backend proving system so that the holder in-circuit signature verification can proceed naturally in the right field.

\begin{mdframed}[style=zkprotocolwithheader, frametitle=Circuit $C_2$ for the \texttt{show} relation]

We define circuit $C_2(x = (\{f_i\}_{i=1}^K, \{p_i\}_{i=1}^K), w = \{m_i\}_{i=1}^N)$ as follows:

\begin{enumerate}
\item Assert $p_i = f_i(m_1, \dots, m_n) \quad \forall i \in [n]$, i.e. correct evaluation of the predicates
\item Assert $\text{ECDSA.verify}(\sigma_{\text{nonce}}, m_1[1]) = 1$, i.e. that the live nonce signature corresponds to the public key the credential was issued to
\end{enumerate}

\end{mdframed}

As part of computing proof $\pi_{\texttt{show}}^{(i)}$ for presentation $i \in [m]$, the prover computes the Hyrax commitment over the Tom256 curve $com(m_1, \dots, m_N; r_i)$, 
notably with \textit{the same} randomness $r_i$ used during the \texttt{prepareBatch} process.
The verifier will check that this equals the re-randomized commitment $com_i$ from proof $\pi_{\texttt{prepare}}^{(i)}$ for circuit $C_1$. 

\subsection{Adding ZK to Spartan}

Our construction uses Circom in the frontend to compile our computation into an R1CS (instance, witness) pair $(x=(\mathbb{F}, A, B, C, io, n, m), \vec{w})$, 
which we then feed into the Spartan IOP coupled with Hyrax-style Pedersen polynomial commitments.

Recall that our R1CS constraint looks like the following:
$$
(A \cdot \vec{Z}) \circ (B \cdot \vec{Z}) - (C \cdot \vec{Z}) = 0
$$
where our square matrices $A, B, C$ have size $n$ and $\vec{Z} = (\vec{w}, 1, io)$.

Recall that Spartan converts an R1CS constraint into the following zero-check:
\begin{multline*}
\sum_{x \in \{0,1\}^{\log n}} \widetilde{eq}(x, \tau)\,
\bigg[
\bigg(\sum_{y \in \{0,1\}^{\log n}} \widetilde{A}(x,y)\,\widetilde{Z}(y)\bigg)
\bigg(\sum_{y \in \{0,1\}^{\log n}} \widetilde{B}(x,y)\,\widetilde{Z}(y)\bigg) \\
\qquad\qquad
- \bigg(\sum_{y \in \{0,1\}^{\log n}} \widetilde{C}(x,y)\,\widetilde{Z}(y)\bigg)
\bigg] \;=\; 0
\end{multline*}

for some random challenge $\tau \in \mathbb{F}$

There are two components in Spartan that we need to modify to be ZK. 
The first is making the sumchecks ZK. 
The second is to ensure that the opening $\widetilde{Z}$ using the commitment to $\vec{Z}$ does not leak information about our witness $\vec{w}$.

\subsubsection{Adding ZK to sumcheck}

The Spartan protocol consists of several sumchecks in parallel. There are various existing techniques to make sumcheck ZK. 
We employ one using similar methods as in Zhang et. al. \cite{cryptoeprint:2019/1482}, which adds random pads to the sumcheck transcript.

In particular, suppose at each round $i$ of the sumcheck protocol, the prover sends over $s_i(X) := \sum_{} F(r_1, \dots, r_{i-1}, X, x_{i+1}, \dots, x_m)$ 
where $r_i$ is the Verifier challenge sent for round $i$. Then instead of having the verifier check the sumcheck, the prover will prove in ZK that the unpadded transcript satisfies the verifier's (linear) checks.
To do this, the prover will need to commit to the random pads ahead of time. 
Then, as long as the Fiat-shamir challenges is generated from the transcript including these random pad commitments, the prover cannot simply lie about the pads to satisfy the sumcheck relation.

\begin{mdframed}[style=zkprotocolwithheader, frametitle=Adding ZK to sumcheck]
    \begin{enumerate}
        \item Prover commits to pads $r_i(X)$ for all $i \in [\log n]$. These are linear polynomials, and can thus be represented by its $2$ coefficients $r_i[0]$ and $r_i[1]$.
        \item Instead of sending partial sums 
        \begin{equation*}
        s_i(X) := \sum_{(x_{i+1}, \dots, x_n) \in \{0,1\}^{n-i}} F(r_1, \dots, r_{i-1}, X, x_{i+1}, \dots, x_n)
        \end{equation*}
        for each round of sumcheck, the Prover sends polys $s'_i(X) = s_i(X) + r_i(X)$, essentially a one-time-padded transcript.
        \item It suffices to show the following linear relation in zero-knowledge, 
        \begin{equation*}
        \left[\begin{array}{c|c|c}
        A & B & C
        \end{array}\right]
        \left[\begin{array}{c}
            \vec{S} \\
            \hline
            \vec{R} \\
            \hline
            C \\
            F(r) \\
        \end{array}\right]
        = 
        \vec{0}
        \end{equation*}
        where
        \[
        \vec{S} = 
        \bigl[\, s'_1[0], s'_1[1], \dots, s'_n[0], s'_n[1] \,\bigr]^{\mathsf T}, 
        \]
        is the column vector of sumcheck transcripts such that $s'_i = s'_i(X) = s'_i[0]X + s'_i[1]$, and
        \[
        \vec{R} = 
        \bigl[\, r_1[0], r_1[1], \dots, r_n[0], r_n[1] \,\bigr]^{\mathsf T},
        \]
        is the column vector of random pads, and where matrices $A,B,C$ are given by

        \[
        A = 
        \left[
        \begin{array}{*{12}{c}}
            1      & 2      & 0      & 0      & 0      & 0      & 0      & \cdots & 0      & 0      & 0      & 0      \\
            -r_1   & -1     & 1      & 2      & 0      & 0      & 0      & \cdots & 0      & 0      & 0      & 0      \\
            0      & 0      & -r_2   & -1     & 1      & 2      & 0      & \cdots & 0      & 0      & 0      & 0      \\
            \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \ddots & \vdots & \vdots & \vdots & \vdots \\
            0      & 0      & 0      & 0      & 0      & 0      & 0      & \cdots & -r_{n-1}& -1    & 1      & 2      \\
            0      & 0      & 0      & 0      & 0      & 0      & 0      & \cdots & 0      & 0      & r_n    & 1      \\
        \end{array}
        \right]
        \]
        \[
        B = 
        \left[
        \begin{array}{*{12}{c}}
            -1     & -2     & 0      & 0      & 0      & 0      & 0      & \cdots & 0      & 0      & 0      & 0      \\
            r_1    & 1      & -1     & -2     & 0      & 0      & 0      & \cdots & 0      & 0      & 0      & 0      \\
            0      & 0      & r_2    & 1      & -1     & -2     & 0      & \cdots & 0      & 0      & 0      & 0      \\
            \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \ddots & \vdots & \vdots & \vdots & \vdots \\
            0      & 0      & 0      & 0      & 0      & 0      & 0      & \cdots & r_{n-1}& 1      & -1     & -2     \\
            0      & 0      & 0      & 0      & 0      & 0      & 0      & \cdots & 0      & 0      & -r_n   & -1     \\
        \end{array}
        \right]
        \]
        \begin{equation*}
            C = 
            \begin{bmatrix}
                -1 & 0 \\
                0 & 0 \\
                0 & 0\\
                \vdots & \vdots \\
                0 & 0\\
                0 & -1\\
            \end{bmatrix}
        \end{equation*}

    \item The Prover computes a public random challenge $\alpha$ (e.g. hashing the transcript) and compresses the relation into a dot product
    \begin{equation} \label{eqn:rlc-vector-reln}
        [\vec{u}]
        \left[\begin{array}{c}
            \vec{S} \\
            \hline
            \vec{R} \\
            \hline
            C \\
            F(r) \\
        \end{array}\right]
        = 
        \vec{0}
    \end{equation}
    where $\vec{u} = [1, \alpha, \alpha^2, \dots, \alpha^n] \left[\begin{array}{c|c|c}
        A & B & C
    \end{array}\right]$ is a random linear combination of the rows.
    \item The Prover and Verifier engage in a proof-of-dot product protocol to prove the relation above, such as an Inner Product Argument used in Bulletproofs \cite{cryptoeprint:2017/1066}
    \end{enumerate}
\end{mdframed}

\subsubsection{Adding ZK to the opening of $\widetilde{Z}$}\label{subsubsec:zk-open-Z}

In order to add ZK to the opening of, we simply append $Z$ with random pads, which is equivalent to assigning random evaluations on the remaining points in the hypercube $\{0,1\}^{\log n}$.
so that $\widetilde{Z'}(x_1, \dots, x_{\log n}) = \widetilde{Z}(x_1, \dots, x_{\log n}) + \sum_{x \in P}eq(r, x)Z(x)$,
where $P$ is the set of points in $\{0,1\}^{\log n}$ that used to be assigned $0$ by default, but were filled with random pads. Notice that if any of $Z(x)$ are random, then $\sum_{x \in P}eq(r, x)Z(x)$ is random.
If $n=|Z|$ is not already a power of $2$, then we can simply fill at least one of the remaining evaluations on $\{0,1\}^{\log n}$ with a single random pad. 
If $n=2^m$, we can add another dimension to the hypercube of evaluations of $Z$. 

    % 1. Prover commits to pads r_i(X) (just linear polys)
    % 2. 
    % 3. Prover and verifier engage in mini SNARK to prove linear relations (using a ZK dot product)
    % 4. Prover has to show opening - using a zk dot product (e.g. IPA)

% for i = 1: 
% linear constraint s'_i(0)-r_i(0) + s'_i(1)-r_i(1) = C
% for i = 2 to m (where m = log n)
% linear constraint s'_i(0)-r_i(0) + s'_i(1)-r_i(1) = s'_{i-1}(r_{i-1})-r'_{i-1}(r_{i-1})

% check s'_m(r_m)-r_i(r_m) = f_r where f_r is the claimed value of f(r_1, ... r_m)
% in a separate zkproof, check the opening of f(r_1, ... r_m) from the commitment of f with an IPA

% can use the IPA extractor to construct the snark witness extractor 
% IPA proof of knowledge soundness is in the bulletproof paper Appendix A: (https://eprint.iacr.org/2017/1066.pdf) 
% IPA extractor - proves you know/can get the vectors satisfying to the product relation, 
% which means can extract pads such that, when subtracted from sumcheck transcript, creates valid sumcheck transcript
% which is equivalent to extracting a valid transcript for spartan sumchecks, 
% which is equivalent to knowing witness passing the relation.

\subsection{Cost analysis}

The following section computes the Prover and Verifier costs of Spartan instantiated with Hyrax Pedersen commitments on R1CS instances $(x = \big(\mathbb{F}, A, B, C, io, n, m),\, \vec{w})$, 
where $io$ denotes the vector of public inputs/outputs, $n = |\vec{w}|$ is the dimension of our matrices, 
and $m$ is the number of nonzero entries in our matrices $A,B,C$. We let $Z = (\vec{w}, io, 1)$. 
It is often reasonable to assume that our R1CS matrices are sparse, i.e. $m = O(n)$. However, we present the costs below independent of this assumption.

\begin{itemize}
    \item \textbf{Prover time}: (1) $O(m)$ to generate sumcheck transcript, (2) $O(m)$ to evaluate MLEs of $A,B,C$, (3) $O(n)$ to commit to the MLE of $Z$ (computing $\sqrt{n}$ MSMs of size $\sqrt{n}$) and opening the MLE of $Z$, for a total cost of $O(m)$.
    \item \textbf{Proof length}: (1) $O(\log n) \cdot |\mathbb{F}|$ length of the sumcheck transcript, (2) $O(\sqrt{n}) \cdot |\mathbb{G}|$ length commitment to MLE of $Z$, (3) $O(\log n) \cdot |\mathbb{G}|$ length of argument opening MLE of $Z$, for a total length of $O(\sqrt{n})$ group or field elements.
    \item \textbf{Verifier time}: (1) $O(\log n)$ to verify sumcheck transcript, (2) $O(m)$ to evaluate the MLEs of $A,B,C$ (with sparse commitment scheme and memory checking), (3) $O(\sqrt{n})$ to open the MLE of $Z$, for a total of $O(m + \sqrt{n})$.
\end{itemize}

With the ZK modifications to Spartan, we can see the asymptotic costs remain the same, as follows:

\begin{itemize}
    \item \textbf{Prover time}: additionally computes $O(\log n)$ constant-size commitments to the sumcheck transcript pads $r_i$, and $O(\log n)$ engages in new sumcheck relation IPA (or some other ZK dot product argument) for vector of length $O(\log n)$, which still gives $O(m)$ prover work.
    \item \textbf{Proof length}: sumcheck and openings are the same length but just padded, but added on $O(\log n)$ size $|\mathbb{G}|$ commitments, and a length $O(\log\log n)$ sumcheck relation IPA proof, which still gives a proof length of $O(\sqrt n)$ group or field elements.
    \item \textbf{Verifier time}: no longer needs to do $O(\log n)$ (sumcheck), but still needs $O(m)$ (evaluating MLEs of $A,B,C$) + $O(\sqrt{n})$ (opening MLE of Z) + $O(\log n)$ for sumcheck relation IPA verification, which still gives $O(m + \sqrt{n})$ runtime.
\end{itemize}

\subsection{Security analysis}

The correctness follows immediately from the correctness of the Spartan SNARK and the fact that the Prover uses the same randomness for the Hyrax commitments across the \texttt{show} and \texttt{prepare} circuits for each presentation $i$.  

The soundness of our protocol follows from the soundness of Spartan. In particular, we can extract the full witness credential from the \texttt{prepare} relation.

Intuitively, zero-knowledge follows from the hiding property of the commitment scheme as well as the zero knowledge property of the Spartan zkSNARK proving system;
For proof $i$, simulator can randomly sample the linked commitment $com_i$ both distributions to reuse across both proofs, both in the commitment itself and also in the IPA used to open the Hyrax commitment to $Z(r_1, \dots, r_{\log{n}})$. 
We can show that this commitment is independent of the rest of the view of the Verifier, which consists of the following:

\begin{itemize}
    \item Sumcheck polynomials $\{s'_i(X)\}_{i \in [\log n]}$ for each of the sumchecks in Spartan
    \item $\{r_i\}$ Fiat-Shamir challenges during the sumcheck
    \item Transcript from the IPA on the sumcheck relation in ZK
    \item $\{com(z_i)\}_{i in [\log n]}$ Hyrax commitment to $Z$, which involves a Pedersen commitment to each of the rows of a $\log n \times \log n$ matrix representation of $\vec{Z}$
    \item Transcript from the IPA for opening $Z(r_1, \dots, r_n)$
    \item The claimed value of $Z(r_1, \dots, r_n)$
\end{itemize}

Since we appended random pads to $\vec{Z}$ in our ZK modifiction in Section \ref{subsubsec:zk-open-Z}, the distribution of $Z(r_1, \dots, r_n)$ is random and independent of $Z$, and therefore independent of $\{m_i\}_i$.
Furthermore, $s'_i(X)$ have totally random pads on them and their distribution is independent of $Z$, and therefore independent of $\{m_i\}_i$.
Assuming the hiding property of the Pedersen commitment schemes for messages sent during an IPA, we can also use the simulators for the IPAs without changing their joint distribution with the rest of the transcript.
% i think this works: com (a, h(a)) ~ com (b, h(a)) ~ com (b, c) from hiding property that com(a) ~ com(b) for a =/= b.

Then, we can simply run the piece-wise simulators for each zkSNARK proof for circuits $C_1$ and $C_2$ to simulate the remainder of the view. 


% \begin{enumerate}
%     \item What are key techniques that will be used in our schemes?
%     \begin{itemize}
%         \item What are its inputs and outputs?
%         \item Participants and requirements of the techniques.
%     \end{itemize}
%     \item Describes the complete scheme, from preparation to verification. 
%     \begin{itemize}
%         \item The preliminaries of users when they use our system.
%         \item What is the difference between the preparation of this scheme and the traditional way?
%         \item Some questions we also answer here but just with a compact version, the detailed or proof will be shown in Security or Appendix section.
%         \begin{itemize}
%             \item Is it a dishonest majority setting or something else? 
%             \item What happens when the setting is broken?
%             \item What trust assumptions are our scheme based on?
%             \item Is this quantum-resistant? If not, is it upgradable to quantum-resistant?
%             \item The correctness, soundness, and zk.
%         \end{itemize}
%     \end{itemize}
%     \item Discuss about the compatibility of our system when upgrading from an older system.
%     \begin{enumerate}
%         \item What happens with the older system?
%         \begin{itemize}
%             \item Is it required to change the issuance process? 
%             \item Is it a breaking change or just a soft update?
%             \item What happens with the issued ID, can it be re-used, and re-issued with a new scheme?
%             % should be revoked
%             \item \textbf{It depends on the answer about the final construction. But we have some design constraints that should be followed, which are described in slide 111 of \href{https://docs.google.com/presentation/d/1C4D8zK4gAdafgIEW-2m_qDyyT39gWo0mmFYpwmA8N3M/edit?slide=id.g338a079cb64_0_31\#slide=id.g338a079cb64_0_31}{this doc}} 
%         \end{itemize} 
%         \item What about the new PID?
%         \begin{enumerate}
%             \item What is the difference between the PID of the new scheme and the current version? Is it added more data fields to the current struct?
%             \item If not, is the process from PID to scheme input straightforward (and provable?)?
% % \textbf{            \item What if the Issuer or the ID owner wants to revoke some IDs, does it require the Issuer to update frequently? -- still need to add this}            \item If the Issuer needs to update frequently, what if they are disconnected for a while? 
%             \item What is the trust assumption?
%         \end{enumerate}
%     \end{enumerate}
%     \item After show the detailed construction, we will show more detailed about why our construction should be considered with some detailed.
%     \begin{enumerate}
%         \item What are the main advantages that make zkID outperform other solutions? 
%             \item TODO: wait for benchmarks from the technical team 
%         \item What are the trade-offs if users take our advancement?
%     \end{enumerate}
% \end{enumerate}
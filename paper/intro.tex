People use digital credentials to prove a single fact---such as being over 18, holding a license, or belonging to an organization---without presenting an entire document.
In the W3C model~\cite{w3c-vc-data-model-2}, an issuer signs a credential, a holder keeps it (typically in a wallet application), and a verifier checks a presentation---that is, data derived from one or more credentials and shown to a specific verifier for a specific session. We take this as the baseline flow.

A practical privacy risk arises when the same credential is shown to different services over time. If a presentation exposes a stable technical trace---for example, an identifier or handle that repeats---then services can compare logs later and infer that the sessions likely came from the same source.
We call this linkability: separate presentations that should remain independent become easy to connect. Standards documents explicitly caution against this: the W3C Verifiable Credentials Data Model states that securing mechanisms must not leak information that would enable a verifier to correlate a holder across multiple presentations~\cite{w3c-vc-data-model-2}; and NIST’s federation guidance recommends pairwise pseudonymous identifiers---meaning unique, opaque identifiers for each relying party---to ensure separation across services and reduce the risk of user tracking~\cite{nist-sp800-63c}.
Deployments typically provide two recurring capabilities: device binding (confirming that the credential is presented by the authorized wallet) and revocation/status (learning whether the credential is still valid). To support these, systems often expose stable values.
For device binding, some ecosystems tie a credential to a long-lived cryptographic key under the control of the device so a verifier can accept only “the right wallet”; if the same key reference or its proof is visible across sessions, different verifiers can match their logs~\cite{IETF:FetYasCam25}.
For status, verifiers query whether a credential was suspended or revoked; a one-to-one status reference (for example, a unique status URL per credential) lets the status provider observe which verifier asked about which holder and when~\cite{w3c-vc-data-model-2}.
These two mechanisms keep systems reliable and usable, but because they rely on fixed values, they also leave repeating patterns that make it possible to link separate credential uses.

Device binding and revocation introduce fixed points outside the credential itself: the first in verifier transcripts, the second in status queries. When such points remain stable across uses, separate sessions can be matched. In what follows, we compare designs using a simple reference view: issuers and credential formats remain as deployed; privacy logic is handled on the holder side; and presentations are per-session and non-repeating. We use this view to organize related work next.

\subsection{Related Work}

For the purpose of comparison, we first outline a reference architecture that represents what an anonymous-credential system would ideally look like if it is to integrate smoothly with current infrastructures. In this model, the issuer is treated as fixed components that continue to use their existing public-key algorithms (such as RSA or ECDSA) and standard credential formats (e.g., JWT or mDL), since it's typically difficult to change once deployed. All additional logic is placed in the user’s wallet and the verifier.
The wallet is expected to operate in two stages: an offline Prepare step, which verifies the issuer’s signature once using standard libraries, parses and normalizes credential attributes (for example, turning a date of birth into an integer age), and commits to those attributes using a binding and hiding commitment scheme (a cryptographic way to lock values so they can later be revealed or proven in restricted form); and an online Show step, which runs per presentation, where the wallet selects only the attributes or predicates required by a relying party’s policy, proves them in zero knowledge against the stored commitments, and includes a fresh device signature over the session challenge to ensure the proof is tied to the holder’s device.
A further requirement is modularity: each major function---issuer signature verification, attribute commitment, predicate proofs, and device binding---should be defined as a separate module with a clear interface. This separation makes it possible to swap the underlying proof engine (for example, using a SNARK today or a post-quantum proof system in the future) without requiring changes to parts of the system that are costly or impractical to modify. The purpose of this modular view is to act as a comparison framework: it outlines how a deployment-friendly anonymous-credential stack could be structured, making it easier to compare proposals by the modules they cover, the constraints they address, and the trade-offs they make.

\paragraph{Anonymous Credentials from ECDSA.~\cite{cryptoeprint:2024/2010}}
This work considers environments where credential issuers already sign with ECDSA on standardized curves (such as P-256) and hash data with SHA-256.
The main challenge is that proving correctness of an ECDSA signature in zero knowledge is costly with standard proof systems, because the arithmetic used in P-256 and the bit-level operations in SHA-256 do not align well with the fast polynomial techniques (such as number-theoretic transforms, a method that speeds up polynomial multiplication over special fields) that many modern ZK libraries rely on.
To handle this, the authors introduce custom circuits for ECDSA and SHA-256, and use a layered protocol based on the sum-check technique and a lightweight encoding (Reed–Solomon code) to control proof size.
An additional “consistency check” ensures that the same hidden signing key is used across both the signature and the hash logic.
At presentation, the wallet produces a proof for the verifier and the device also signs a fresh challenge (this is the device-binding step: a live signature that ties the proof to the holder’s device).
In terms of the reference system view, issuer compatibility is preserved, selective disclosure is supported, and device binding is included; however, there is no reusable offline phase, so the full proof is generated at every presentation. The reported costs are about 60\,ms to prove one ECDSA signature and about 1.2\,s for a complete mDL presentation on mobile devices~\cite[\S5.3,\S6.2]{cryptoeprint:2024/2010}, with larger proof sizes and higher verifier effort than systems based on succinct setup-dependent SNARKs.

\paragraph{Crescent Credentials.~\cite{cryptoeprint:2024/2013}}
This work considers environments where issuers continue using existing credential formats such as JWT or mDL and their current signing keys, so no issuer-side changes are required.
Its workflow is split into a heavy one-time Prepare phase and a lightweight per-presentation Show phase.
In Prepare, the wallet verifies the issuer’s signature, parses the credential into attributes, and creates two reusable artifacts---that is, cryptographic objects the wallet reuses across presentations: (i) a Groth16 proof that these checks were done correctly, and (ii) a Pedersen vector commitment over the attributes, enabling selective disclosure.
Both artifacts support re-randomization for unlinkability.
In the Show phase, the wallet re-randomizes the prepared artifacts and attaches only the proofs required by the verifier’s policy, such as proving an age threshold or linking two credentials to the same holder. Device binding can be added at this step by letting the secure element sign the verifier’s challenge.
In terms of the reference system view, Crescent realizes the two-phase design with reusable offline work and modular predicates, while leaving issuers unchanged. The trade-offs are significant: the Prepare phase is heavy (tens of seconds for JWTs and minutes for mDLs), the scheme depends on pairing-based Groth16 proofs with a large universal setup ($\approx$ 661 MB–1.1 GB~\cite[\S4]{cryptoeprint:2024/2013}), and the security model is classical only, without post-quantum protection. The Show step, however, runs with low latency-typically 22–41\,ms with $\approx$1 KB proofs, or about 315\,ms with device binding~\cite[\S4]{cryptoeprint:2024/2013}.

\paragraph{zkID.}
Our construction works with standardized credentials (e.g., SD-JWT, mDL) and existing PKI (RSA/ECDSA), so issuers do not need to change their issuance pipelines.
The zkID workflow follows the two-phase split in the reference view: a one-time Prepare phase and a per-presentation Show phase.
In Prepare, the wallet verifies the issuer’s signature, parses the credential into normalized messages, computes the associated hashes, and produces two reusable artifacts: (i) zero-knowledge proofs that issuer-side checks and parsing were done correctly, and (ii) Hyrax-style Pedersen vector commitments to a designated message column, supporting efficient proofs over multiple attributes.
In Show, the wallet proves only the verifier’s requested predicates and includes a fresh device-binding signature. To link Prepare and Show without revealing values, the verifier checks equality of commitments across both proofs; the wallet reuses the corresponding randomness for that session.
The proving backend is transparent (no trusted setup). It checks the arithmetic constraints with a sum-check–style protocol and uses a small inner-product check to verify commitment openings. For device binding, we choose a curve whose scalar field matches the device’s signature field (e.g., P-256), so the device signature can be verified directly inside the proof without emulation or field translation. 
In terms of the reference system view, issuer compatibility is preserved, the two-phase reuse is integrated into the workflow, predicates are modular, and there is no trusted setup. The trade-offs are that security currently relies on discrete-log assumptions (not post-quantum) and that commitment equality requires using the same curve across Prepare and Show; the modular interface leaves room to swap in lattice-based commitments when suitable.

Taken together, these approaches show the current trade-off: systems either reuse existing issuer infrastructure but pay high per-presentation costs, or they achieve fast online proofs at the price of large setups and pairing-based assumptions. Our construction, zkID, aims to combine issuer compatibility with reusable offline work, while remaining transparent and modular. Before presenting the design, we review the algebraic and cryptographic preliminaries that will be used throughout the paper.

People use digital credentials to prove a single fact—such as being over 18, holding a license, or belonging to an organization—without presenting an entire document. In the W3C model~\cite{w3c-vc-data-model-2}, an issuer signs a credential, a holder keeps it (typically in a wallet application), and a verifier checks a presentation—that is, data derived from one or more credentials and shown to a specific verifier for a specific session. This is the baseline flow we adopt.

A practical privacy risk arises when the same credential is shown to different services over time. If a presentation exposes a stable technical trace—for example, an identifier or handle that repeats—then services can compare logs later and infer that the sessions likely came from the same source.
We call this linkability: separate presentations that should remain independent become easy to connect. Standards documents explicitly caution against this: the W3C Verifiable Credentials Data Model states that securing mechanisms must not leak information that would enable a verifier to correlate a holder across multiple presentations~\cite{w3c-vc-data-model-2}; and NIST’s federation guidance recommends pairwise pseudonymous identifiers - meaning unique, opaque identifiers for each relying party - to ensure separation across services and reduce the risk of user tracking~\cite{nist-sp800-63c}.
Deployments typically provide two recurring capabilities: device binding (confirming that the credential is presented by the intended wallet) and revocation/status (learning whether the credential is still valid). To support these, systems often expose stable values.
For device binding, some ecosystems tie a credential to a long-lived cryptographic key under the control of the device so a verifier can accept only “the right wallet”; if the same key reference or its proof is visible across sessions, different verifiers can match their logs~\cite{IETF:FetYasCam25}.
For status, verifiers query whether a credential was suspended or revoked; a one-to-one status reference (for example, a unique status URL per credential) lets the status provider observe which verifier asked about which holder and when~\cite{w3c-vc-data-model-2}. Both mechanisms illustrate how operational stability keeps systems usable yet simultaneously introduces recognizable patterns that compromise unlinkability.

We preserve the operational stability that deployments need while preventing correlators at verification.
Concretely, zkID adds a presentation-layer wrapper—a thin layer at the presentation step (in the W3C sense) that re-randomizes what the verifier observes. After a one-time *prepare* when the wallet stores a credential, each session produces a fresh, per-session randomized proof; the verifier, in addition to its normal signature and policy/status checks, performs one extra consistency check to confirm that the randomized proof matches the underlying credential.
We analyze unlinkability under a practical model in which holders may be malicious and verifiers may collude by comparing what they observe across sessions; issuers do not collude with verifiers, and issuance flows and keys remain unchanged.
Under this model, presentations remain verifiable for services while no reusable handle is exposed to link sessions—consistent with the W3C requirement~\cite{w3c-vc-data-model-2}.

Our design does not require changes to issuers. Modifications occur only at the two endpoints of presentation: (i) the wallet runs a one-time prepare when storing a credential and, at each use, generates a randomized proof so two verifiers do not observe the same handle; and (ii) the verifier adds one consistency check alongside its existing validation to confirm that the randomized proof aligns with the presented credential. We evaluate zkID under these deployment constraints.

\subsection{Related Work}

\paragraph{Anonymous Credentials from ECDSA.}
Matteo Frigo and Abhi Shelat (Google) propose an anonymous credential scheme for legacy-deployed ECDSA that preserves deployability on existing infrastructures (e.g., P-256, SHA-256) without issuer or device changes and without trusted setup, addressing reluctance to upgrade infrastructures that only support RSA/ECDSA~\cite{cryptoeprint:2024/2010}. Their design tackles the bottleneck of zero-knowledge proofs over non-NTT-friendly curves by building a proof stack around sum-check and the Ligero argument~\cite{CCS:AHIV17}, introducing specialized ECDSA circuits and efficient Reed–Solomon encodings, and adding a witness-consistency mechanism to keep common witness values aligned across arithmetic over $\mathbb{F}_{p}$ (ECDSA) and $\mathrm{GF}(2^k)$ (SHA-256). As reported, the system generates a proof for a single ECDSA signature in 60 ms and a zero-knowledge proof for the ISO/IEC 18013-5 mDL presentation flow in 1.2 s on mobile devices~\cite[\S5.3,\S6.2]{cryptoeprint:2024/2010}. Device binding follows the mDL live-challenge pattern. The main trade-off is comparatively larger proofs and higher verifier workload than succinct CRS-based SNARKs.

\paragraph{Crescent Credentials.}
Christian Paquin, Guru-Vamsi Policharla, and Greg Zaverucha introduce Crescent to upgrade privacy of existing credentials (JWTs, mDL) with selective disclosure and unlinkability without changing issuance processes~\cite{cryptoeprint:2024/2013}. Crescent achieves fast online presentations with compact proofs, while relying on a two-phase workflow:
\begin{itemize}
  \item Prepare (offline, once per credential): verify issuer signatures, decode and parse the credential into attributes, and produce a Pedersen vector commitment via a Groth16 proof. Reported timings are approximately 27 s for a 2 KB JWT and 140 s for an mDL, with universal-setup parameters of size approximately 661 MB–1.1 GB~\cite[\S4]{cryptoeprint:2024/2013}.
  \item Show (online, per presentation): re-randomize the Groth16 proof and attach a few proofs over committed attributes; typical latencies are approximately 22 ms for JWT and 41.2 ms for mDL, with proofs around 1 KB. Optional device binding increases these costs (e.g., about 315 ms Show, about 184 ms verify; proof size about 15 KB)~\cite[\S4]{cryptoeprint:2024/2013}.
\end{itemize}
Crescent exposes a modular committed-attribute interface that admits sub-provers for range checks, credential linking, and binding to session context or device by proving knowledge of a signature under a committed public key. The principal trade-offs are reliance on pairing-based Groth16 with a trusted setup and large universal parameters, and a comparatively heavy (but amortized) offline Prepare phase; in its current form Crescent is not post-quantum secure~\cite{groth2016size}.

\paragraph{zkID.}
zkID is a modular, transparent (no-CRS) zero-knowledge wrapper for standardized credentials, prioritizing unlinkability and deployability. We adopt the same two-phase workflow as Crescent but avoid a universal setup, and we retain ECDSA compatibility as in Google’s design while moving issuer verification to the offline phase to reduce online verifier work. Key distinctions from prior work include:
\begin{itemize}
  \item Transparency: no trusted setup; standard discrete-log assumptions; 
  \item Deployment compatibility: interoperates with mDL/SD-JWT and existing PKI (ECDSA or RSA) without changes to issuer processes or secure elements.
%   \item Reduced online burden: relative to prior ECDSA-based designs, issuer-signature verification and parsing move to the offline Prepare phase, reducing online compute.
  \item Avoidance of pairing-based cryptography: unlike pairing-based schemes, zkID avoids pairing-friendly curves.
  \item Verifier cost: reduces verifier work relative to prior ECDSA-based designs under our constraints while preserving unlinkability under the stated threat model.
\end{itemize}

In summary, zkID shows that a modular, standards-aligned zero-knowledge wrapper over existing credential formats can be built. Compared to pairing-based schemes, it avoids dependence on pairing-friendly curves; compared to universal-setup SNARK wrappers, it avoids a trusted setup; and relative to prior ECDSA-based designs, it reduces verifier cost while preserving unlinkability under our model. The construction is transparent and PQC-agile; the current instantiation is classical and not quantum-resistant.

In our evaluation, zkID achieves practical performance on commodity hardware. For a typical credential with ..., the one-time \emph{Prepare} phase completes in ... seconds on a standard laptop (or mobile) (..., ...GB RAM), while the per-presentation \emph{Show} phase takes less than ... ms on a mid-range smartphone. Proof sizes are approximately ... KB for the full protocol, and verifier time remains below ... ms on a web server. These results demonstrate that zkID meets latency and resource targets for mobile and web deployments, while preserving unlinkability and avoiding trusted setup. Detailed benchmark results and further breakdowns will be provided in Section~\ref{sec:experiments}.